# MySweetBakery 

조작키 : 캐릭터 이동 (WASD)
           빵 담기 (숫자 키 : 1)
           빵 진열하기 (숫자 키 : 2)
           돈 줍기 (숫자 키 : 3)


[기능 설명]


[Object Pool]

- 고객(Customer), 빵(Bread), Money(돈), 종이가방(PaperBag), 사운드(Sound), 이펙트(Effect) 풀링으로 구현 

- 각각 빈 오브젝트인 Manager 오브젝트에 풀 Script를 담았으며 (개별적으로 초기 풀 크기 설정 가능)

- 풀링으로 구현된 모든 오브젝트들은 사용 시점에 풀에서 꺼내와 활성화하며 사용이 끝나는 시점에 풀으로 반납후 비활성화


[Camera]

- Target인 플레이어를 따라 다니도록 구현 

- 카메라의 (줌 인, 줌 아웃) 기능을 코루틴으로 구현 
   - 코루틴 시작 전 카메라의 기존 Position을 저장해놓고 줌 아웃 코루틴에서 기존 Poistion으로 돌아가도록 구현 

- 플레이어가 아닌 다른 Target을 타겟팅하는 동안은 Update에서 플레이어를 따라다니는 로직을 실행하지 않도록 구현  


[Player]

- Enum-Switch문으로 FSM 구성 

- 플레이어는 각각 상호작용할 오브젝트와의 거리를 측정해 특정 행동 가능

- 플레이어가 주운 빵은 Stack으로 보관
   (진열대에 빵을 놓을때 가장마지막에 쌓인 위에있는 빵부터 놓기 위해 Stack 자료구조를 이용)

- 최대 빵을 8개 담을 수 있으며 MaxStackCount에 도달하는 순간 max 텍스트 캔버스를 띄움


[Bread Oven] - 오븐

- 오븐에서 빵을 주기적으로 구워내며 오븐 앞의 바구니에 떨어져서 담기도록 구현 

- 바구니에 빵이 담길 때 마다 Queue 자료구조에 담음

- 바구니에 존재하는 빵이 담을 수 있는 최대 개수 만큼 담겼으면 빵 생산 코루틴 종료 

- 바구니에 존재하는 빵이 담을 수 있는 최대 개수 보다 적으면 코루틴 시작 


[DisPlayBread] - 빵 진열대 


- 진열대의 빵이 쌓이면 Stack으로 관리
  (마지막에 놓인 빵을 우선적으로 고객이 가져가기 위함)

- bool 자료형 List를 이용해 현재 고객이 이용중인 자리인지 아닌지 여부 판단 가능하도록 구현 
 (고객이 이용할 수 있는 자리는 총 3군데 있음)


[Counter] 

- bool 자료형 List를 이용해 현재 고객이 계산하기 위해 설 수 있는 줄을 판단 가능하도록 구현 
 (고객은 최대 3명까지 줄 설 수 있음)

- 고객은 빵을 포장 후 카운터에 돈을 두고 감
  빵이 1개라면 5원 , 빵이 2개라면 10원, 빵이 3개라면 20원 

- 카운터에 쌓인 돈이 30원이 넘는다면 카메라가 봉인된 지역으로 Targetting을 시작 함

[쌓이는 돈 구현 방식]

- 돈이 쌓이기 시작할 위치 지정
- 스크립트에서 행,열,층 각각 몇으로 할지 지정 
- Spacing (X,Y,Z) - (Grid) 지정 

- 시작 할 때 각 층에서의 각 행과 열에 해당하는 위치를
  Queue에 모두 담아 둠

- 고객이 돈을 지불할 때, 10원이라면 for문을 10번 돌며 
  돈 오브젝트를 풀에서 활성화시켜 가져와 Queue에서 꺼낸 위치에 순차적으로 쌓음
  과 동시에 돈 오브젝트를 Stack에도 넣어놈 
  (플레이어가 돈을 회수할 때 가장 마지막에 위치한 돈부터 순차적으로 회수하기 위함)

- *** 이 때, 중요한게 회수한 돈위치에 다시 돈이 쌓이지 않는 방식을 해결하기 위해 
       한번 Stack에서 빼낼 때 마다 임시 큐를 만들어 기존의 위치가 저장된 Queue를 저장하고 기존의 Queue는 Clear 시킴
       회수된 돈의 위치정보를 Queue에 다시 첫번째 원소로 넣고 그 뒤에 임시큐의 정보를 다시 담음

       (회수된 위치에서도 다시 돈이 쌓이도록 구현 완료)


[Cafeteria]

- 플레이어가 30원 이상 가지고 있다면 봉인된 지역 (돈 이미지)의 위치와 플레이어의 거리가 상호작용할 수 있는 거리인지 체크 후 
  가능하다면 30원을 빨아들이며 봉인된 지역을 카페로 변경 
 
- 이 때, 이펙트는 풀링으로 구현, 창문 애니메이션은 코루틴을 이용한 스케일 값 조정으로 구현 


[Customer]

- Enum-Switch문으로 FSM 구성 

- 고객이 목적지로 이동할 때, 즉각적으로 이동해야 할 방향을 바라보기 위해 agent의 회전 제어를 끄고 직접 회전 제어 코드 구현 

- 목적지에 도착한 후 오브젝트쪽을 바라보기 위해 RotationObj 함수 구현 
  (이 때, 가독성과 사용 편리성을 위해 딕셔너리에 Key,Value 쌍으로 바라봐야할 오브젝트의 Transform을 담아 둠)  

ex) 오브젝트를 바라봐야 할 때, RotationToObj(customerController.objectTr["진열대"]); 이런식으로 이름으로 참조해서 쓰도록 구현 


[AI Logic]

Step1 (카페 사용하지 않는 손님)

- 고객은 문에서 들어와 빵 진열대로 감 (사용가능 한 자리를 알아내 사용가능한 자리로 감)
         
- 빵 진열대에 서면 머리 위 말풍선이 생기며 말풍선에 적힌 빵의 개수만큼 빵을 담음
        
- 이 때, 담은 빵은 Queue에 쌓임 (카운터에서 포장할 때 먼저 담은것을 먼저 빼내기 위함) 
                                                      (가장 위에있는것 부터 빼내고 싶다면 Stack 이용해도 좋음)
         
- 쌓은 빵을 포장하기 위해 카운터로 향함 ( 카운터의 줄이 꽉 찼는지 여부 판단 후 비어있으면 카운터로 향함 )
  과 동시에 스폰 가능한 고객이 몇명인지 여부 판단 후 고객 스폰 ( 빵 진열대를 이용할 수 있는 3개의 자리중에 비어있는 만큼 활성화 )
         
- 첫 번째 줄에 서있는 고객부터 포장을 시작하며 첫 번째 줄 고객이 포장을 완료하면 돌아서 문으로 나감 
  (두 번째 줄에 서있는 고객은 첫번째 줄로, 세 번째 줄에 서있는 고객은 두 번째 줄로 당기도록 구현)
  (과 동시에 서있던 줄의 자리를 List 갱신으로 사용가능하도록 구현)  


Step2 (카페 사용하는 손님)

- Customer Spawner에서 고객을 풀에서 활성화할 때 고객은 Spawn Count를 부여받음 (몇 번째로 활성화된 고객인지)
- Spawn Count가 4인 (4번째로 활성화된 고객)을 카페를 사용하는 고객으로 구현 


[Arrow]

- Arrow는 목표지점을 가리키는 Arrow와 
  플레이어로부터  Arrow가 가리키고 있는 목표지점까지 나아가야 할 방향을 알려주는 Nav Arrow가 있음 

- Arrow는 특정 Flag가 있을 때, 목표지점을 바꿔 가리키며 Sin 곡선을 통한 위 아래 움직임 애니메이션을 구현
  Arrow의 Target이 변경될 때 마다 currentTarget이 변경됨

- NavArrow는 Arrow의 currentTarget을 추적하도록 매 프레임 업데이트 하는 구조

Arrow가 참조해야할 위치 정보 또한 가독성과 사용편리성을 위해 딕셔너리로 Key : string , Value : Transform으로 담아둠 

ex) Arrow 위치를 변경해야 하는 특정 플래그가 있을 때 , arrowTr["카페"] 이런식으로 이름으로 참조해서 쓰도록 구현 
          
